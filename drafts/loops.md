# Loops

Computers are very good at repeating instructions. To have them do so, we
use _loops_.  There are many kinds of loops. We can group them in 4 categories,
with various sub-categories introduced, in Python, by using either the
keyword `continue` or `break`. Excluding the sub-categories, and given a set
of instructions to repeat, the four basic loops categories are:

1. repeat the instructions a fixed number of times
2. repeat them **while** a condition is satisfied
3. repeat them **until** a condition is satisfied
4. repeat them forever

In what follows, I will refer to these categories simply as

1. repeat n
2. repeat while condition
3. repeat until condition
4. repeat forever

I note that, for experienced programmers, the last two categories are usually
considered to be a single one, where one uses boolean logic (`not` in Python)
to transform a **while** type into an **until** type. However, this is not
the case for all beginners which has lead some designers of block-based programming
environments to distinguish between these two categories.

## Examples from Scratch

Scratch control blocks includes only 3 of the four categories:

1. repeat n

![](/images/scratch_repeat_n.png)

3. repeat until condition

![](/images/scratch_repeat_until.png)

4. repeat forever

![](/images/scratch_repeat_forever.png)

Note that the word _repeat_ is absent for the infinite (forever) loop.
This is not the case for all languages; for example, the French version
does include the translation of _repeat_ for all 3 types of loops
including the infinite one.

![](/images/scratch_repeat_forever_fr.png)
![](/images/scratch_repeat_n_fr.png)
![](/images/scratch_repeat_until_fr.png)

To a Python programmer, it may come as a surprise that the `repeat until condition` is
included but not `repeat while condition`. Given the work that went into designing Scratch,
there is likely a fair bit of research that
lead to choosing this variant as the easiest and most natural
one to understand by beginners.
This might be because Scratch supports
programs with user interactions, such as mouse or key events,

![](/images/scratch_events.png)

and that, most often, one might want to keep on repeating **until** a
certain event takes place.

![](/images/scratch_repeat_until_event.png)

## Examples from Blockly

Blockly also includes only 3 of the four loop categories, but they are
not the same as Scratch.

1. repeat n

![](/images/blockly_repeat_n.png)

2. repeat while condition

![](/images/blockly_repeat_while.png)

3. repeat until condition

![](/images/blockly_repeat_until.png)

`repeat while condition` and `repeat until condition` are variants of a single block

![](/images/blockly_repeat_while_until.png)

Blockly does not include a `repeat forever` block.

### From Blockly to Python

Blockly can translate block configurations into valid code for various
programming languages including Python.  Here, we show two examples
from [Reeborg's World](http://reeborg.ca/reeborg.html).


![](/images/blockly_example2_python.png)

(The color scheme used for individual blocks is different in Reeborg's World
as compared with that used in Blockly; standard Blockly blocks for loops are
green whereas they are blue for Reeborg's World.)


![](/images/blockly_example_python.png)

As we can see, the required indentation of Python's syntax is a very
natural counterpart to Blockly's structure.

[Reeborg's World](http://reeborg.ca/reeborg.html) can also use the Javascript
version of the code generated by Blockly. While Javascript does not attach
any meaning to code indentation, Blockly nonetheless uses indentation to
help users connect the textual and the block representation of a given
code sample.

![](/images/blockly_example_javascript.png)

### Further loops from Blockly

In addition to a variable-less version of `repeat n`, Blockly makes it
possible to define a block that is very similar to the more complex
version of Python's `for var in range(...)`.

![](/images/blockly_for_count.png)

It also includes a loop with a finite number of repetitions set by
the number of elements in a container

![](/images/blockly_for_each.png)

## Python loops

Python programmers think of loops as coming in two flavours:
`for` loop and `while` loops.  Let's see how the four categories we
have identified are written in Python.

We start with the second case, `repeat while condition`.  It is written as

```py
while condition:
    # block of code
```

which is essentially the simplest syntax one can imagine. The third case,
`repeat until condition`, is derived from the second using boolean logic

```py
while not condition:
    # block of code
```

Mentally translating `while not condition` into `until condition` is something
that experienced programmers do effortlessly, but which requires a conscious
effort for beginners.

The `repeat forever` case is usually written with the following Python idiom

```py
while True:
    # block of code
```

This is something that is normally learned rather than quickly and
intuitively deduced. Before `True` became a keyword, it used to be written as

```py
while 1:
    # block of code
```
which required even one more step of mental gymnastics before being understood.
Of course, once one has learned the idiom, it is trivially recognized.

This leaves us with what we labeled as the first category, `repeat n`.
Before showing the normal Python syntax for this case, it might be useful
to consider a more general case.

Often one will write a program where a given series of instructions will
be applied to a collection.  Here are some examples of how this is done
with Python:

```py
# iterating over a list
for item in [1, 2, 3]:
    print(item)    # or do something else with the item ...

# iterating over a string:
for letter in "Python":
    print(letter)

# iterating over the keys of a dict
for key in {'a': 1, 'b': 2, 'c': 3}:
    print(key)

# iterating over a tuple
for item in (1, 2, 3):
    print(item)

# iterating over a set:
for element in {1, 2, 3}:
    print(element)

# iterating over a file; note that this is not the recommended way
for line in open('test.txt'):
    print(line)
```

The general pattern is

```py
for item in some_iterable:
    do_something(item)   # this can be an arbitrary code block
```

It is a powerful pattern which is definitely one of Python's strengths.
It also needs to be understood before introducing the very useful
list comprehensions and generator expressions in Python.

In the absence of a collection that has a set number of items
Python introduces a special built-in iterable, `range()`,
which is then used in the generic for loop construct.

```py
for some_variable in range(n):
    # block of code
```

For experienced programmers, reusing such a powerful and relatively
simple pattern for iterations is great.
However, I would argue that it is less than ideal for beginners, and certainly
not as intuitive as the textual descriptions of the blocks used in Scratch
or Blockly, which would translate in a Python-like language as

```py
repeat n:
    # block of code
```

### A digression: Ruby's loops

Python's philosophy is described in the _Zen of Python_, written ty Tim Peters.
Loops in Python definitely conform to the idea that

> _There should be one-- and preferably only one --obvious way to do it._

Meanwhile, Ruby's philosophy, though not codified, appears to be that
a programmer should be given as many ways as possible to express a given
construct.

For example, unlike Python, Ruby has both a `while` loop

```rb
while condition do
   # code
end
```

and an `until` loop

```rb
until condition do
   # code
end
```

Using `begin` instead of `do`, the test can be also put at the end of a loop,
ensuring that at least one iteration is done

```rb
begin
  # code
end until condition
```

```rb
begin
  # code
end while condition
```

Repeating instructions a fixed number of times, without needed
a variable to label each repetition, can be easily achieved, as in

```rb
3.times do
  puts 'Hello'
end
```

Beginners encountering such loops for the first time would likely
grasp much more easily Ruby's syntax than the corresponding Python idiom

```py
for _ in range(3):
   print('Hello')
```


If we need to refer to the variable, we can add it this way:

```rb
3.times do |n|
  puts n
end
```

This can also be written as

```rb
for n in 0..2 do
  puts n
end
```

There are yet more ways to write the same loop in Ruby; for example

```rb
(0..2).each do |i|
  puts i
end
```

or

```rb
(0..2).each {|i| puts i}
```

or

```rb
0.upto(2).each {|i| puts i}
```

Finally, instead of keyword-defined loops, we can use the `loop` method.
For example, and infinite loop can be written as

```rb
loop do
   # code
end
```


I believe that Ruby's syntax
makes it easier for beginners to conceptually understand loops when they
see them for the first time. However, it is likely more difficult for beginners
to recognize all the possible ways to achieve a given result using loops,
and the subtle differences between each of the approaches.


## Digging through the archives

Add text



